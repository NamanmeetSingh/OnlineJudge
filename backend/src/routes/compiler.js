const express = require('express');
const { authenticateToken } = require('../middleware/auth');
const Problem = require('../models/Problem');
const Submission = require('../models/Submission');
const { validationResult, body } = require('express-validator');
const GeminiService = require('../services/GeminiService');

const router = express.Router();

// Validation middleware
const executeValidation = [
  body('code').notEmpty().withMessage('Code is required'),
  body('language').isIn(['javascript', 'python', 'java', 'cpp', 'c']).withMessage('Unsupported language'),
  body('input').optional().isString()
];

const submitValidation = [
  body('code').notEmpty().withMessage('Code is required'),
  body('language').isIn(['javascript', 'python', 'java', 'cpp', 'c']).withMessage('Unsupported language'),
  body('problemId').notEmpty().withMessage('Problem ID is required')
];

// Execute code (for testing - Run button) - Now uses Gemini API
router.post('/execute', authenticateToken, executeValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { code, language, input = '' } = req.body;

    // Create a simple test case from the input
    const testCases = input ? [{ input, expectedOutput: 'Output will be generated by Gemini API' }] : [];

    try {
      // Initialize Gemini service
      const geminiService = new GeminiService();
      
      // Execute code using Gemini API
      const result = await geminiService.executeCode(code, language, testCases);

      res.json({
        success: true,
        data: {
          output: result.results[0]?.actualOutput || 'Code executed successfully',
          status: 'success',
          executionTime: result.results[0]?.executionTime || 0,
          memoryUsed: result.results[0]?.memoryUsed || 0,
          error: null
        }
      });

    } catch (geminiError) {
      console.error('Gemini API error:', geminiError);
      res.status(500).json({
        success: false,
        message: 'Code execution failed via Gemini API',
        error: geminiError.message
      });
    }

  } catch (error) {
    console.error('Code execution error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Code execution failed',
      error: error.message
    });
  }
});

// Test code against sample test cases (for testing - Enhanced Run button)
router.post('/test-samples', authenticateToken, [
  body('code').notEmpty().withMessage('Code is required'),
  body('language').isIn(['javascript', 'python', 'java', 'cpp', 'c']).withMessage('Unsupported language'),
  body('problemId').notEmpty().withMessage('Problem ID is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { code, language, problemId } = req.body;

    // Get problem with examples (sample test cases)
    const problem = await Problem.findById(problemId);
    if (!problem) {
      return res.status(404).json({
        success: false,
        message: 'Problem not found'
      });
    }

    if (!problem.examples || problem.examples.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No sample test cases available for this problem'
      });
    }

    // Prepare sample test cases for Gemini API
    const sampleTestCases = problem.examples.map((example, index) => ({
      input: example.input,
      expectedOutput: example.output,
      testCaseNumber: index + 1
    }));

    try {
      // Initialize Gemini service
      const geminiService = new GeminiService();
      
      // Execute code using Gemini API
      const result = await geminiService.executeCode(code, language, sampleTestCases);

      res.json({
        success: true,
        data: {
          overallPassed: result.overallPassed,
          passedCount: result.passedCount,
          totalCount: result.totalCount,
          results: result.results
        }
      });

    } catch (geminiError) {
      console.error('Gemini API error:', geminiError);
      res.status(500).json({
        success: false,
        message: 'Code execution failed via Gemini API',
        error: geminiError.message
      });
    }

  } catch (error) {
    console.error('Sample test execution error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Failed to execute sample tests',
      error: error.message
    });
  }
});

// Submit solution (for evaluation - Submit button)
router.post('/submit', authenticateToken, submitValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { code, language, problemId } = req.body;
    const userId = req.user.id;

    // Get problem with test cases
    const problem = await Problem.findById(problemId).select('+testCases');
    if (!problem) {
      return res.status(404).json({
        success: false,
        message: 'Problem not found'
      });
    }

    // Prepare test cases for Gemini API
    const testCases = problem.testCases.map(tc => ({
      input: tc.input,
      expectedOutput: tc.expectedOutput
    }));

    try {
      // Initialize Gemini service
      const geminiService = new GeminiService();
      
      // Submit solution using Gemini API
      const result = await geminiService.submitSolution(code, language, problemId, testCases, problem.functionSignature);

      // Determine final status
      let finalStatus = 'wrong_answer';
      if (result.status === 'accepted') {
        finalStatus = 'accepted';
      } else if (result.status === 'runtime_error') {
        finalStatus = 'runtime_error';
      } else if (result.status === 'compilation_error') {
        finalStatus = 'compilation_error';
      }

      // Save submission to database
      const submission = new Submission({
        user: userId,
        problem: problemId,
        code,
        language,
        status: finalStatus,
        executionTime: result.executionTime,
        memoryUsed: result.memoryUsed,
        passedTestCases: result.passedTestCases,
        totalTestCases: result.totalTestCases,
        testCaseResults: result.testCaseResults.map(tc => ({
          testCaseId: tc.testCaseNumber,
          status: tc.status === 'passed' ? 'Passed' : 'Failed',
          executionTime: tc.executionTime,
          memoryUsed: tc.memoryUsed,
          input: tc.input,
          expectedOutput: tc.expectedOutput,
          actualOutput: tc.actualOutput,
          errorMessage: tc.error
        })),
        compilationError: finalStatus === 'compilation_error' ? 'Function signature mismatch or compilation error' : undefined,
        runtimeError: finalStatus === 'runtime_error' ? 'Runtime error during execution' : undefined
      });

      await submission.save();

      // Update problem statistics
      await Problem.findByIdAndUpdate(problemId, {
        $inc: {
          totalSubmissions: 1,
          ...(finalStatus === 'accepted' && { acceptedSubmissions: 1 })
        }
      });

      // Update user statistics if accepted
      if (finalStatus === 'accepted') {
        // You can add user statistics update here
      }

      res.json({
        success: true,
        data: {
          submissionId: submission._id,
          status: finalStatus,
          executionTime: result.executionTime,
          memoryUsed: result.memoryUsed,
          passedTestCases: result.passedTestCases,
          totalTestCases: result.totalTestCases,
          testCaseResults: result.testCaseResults
        }
      });

    } catch (geminiError) {
      console.error('Gemini API error:', geminiError);
      res.status(500).json({
        success: false,
        message: 'Solution submission failed via Gemini API',
        error: geminiError.message
      });
    }

  } catch (error) {
    console.error('Solution submission error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Solution submission failed',
      error: error.message
    });
  }
});

// Execute function with sample test cases (LeetCode style - Enhanced Run button) - Now uses Gemini API
router.post('/execute-function', authenticateToken, [
  body('code').notEmpty().withMessage('Code is required'),
  body('language').isIn(['javascript', 'python', 'java', 'cpp', 'c']).withMessage('Unsupported language'),
  body('problemId').notEmpty().withMessage('Problem ID is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { code, language, problemId } = req.body;

    // Get problem with examples (sample test cases)
    const problem = await Problem.findById(problemId);
    if (!problem) {
      return res.status(404).json({
        success: false,
        message: 'Problem not found'
      });
    }

    if (!problem.examples || problem.examples.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No sample test cases available for this problem'
      });
    }

    // Prepare sample test cases for function-based execution
    const sampleTestCases = problem.examples.map(example => ({
      input: example.input,
      expectedOutput: example.output
    }));

    try {
      // Initialize Gemini service
      const geminiService = new GeminiService();
      
      // Get function signature for the selected language
      const functionSignature = problem.functionSignature?.[language];
      if (!functionSignature) {
        return res.status(400).json({
          success: false,
          message: 'Function signature not available for the selected language'
        });
      }

      // Execute function code using Gemini API
      const result = await geminiService.executeFunctionCode(code, language, sampleTestCases, functionSignature);

      res.json({
        success: true,
        data: {
          overallPassed: result.overallPassed,
          passedCount: result.passedCount,
          totalCount: result.totalCount,
          results: result.results,
          executionTime: result.results.reduce((sum, r) => sum + (r.executionTime || 0), 0),
          status: result.overallPassed ? 'success' : 'wrong_answer'
        }
      });

    } catch (geminiError) {
      console.error('Gemini API function execution error:', geminiError);
      res.status(500).json({
        success: false,
        message: 'Function execution failed via Gemini API',
        error: geminiError.message
      });
    }

  } catch (error) {
    console.error('Function execution error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Function execution failed',
      error: error.message
    });
  }
});

// Submit function-based solution (LeetCode style - Submit button)
router.post('/submit-function', authenticateToken, submitValidation, async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { code, language, problemId } = req.body;
    const userId = req.user.id;

    // Get problem with test cases
    const problem = await Problem.findById(problemId).select('+testCases');
    if (!problem) {
      return res.status(404).json({
        success: false,
        message: 'Problem not found'
      });
    }

    // Prepare test cases for function-based execution
    const testCases = problem.testCases.map(tc => ({
      input: tc.input,
      expectedOutput: tc.expectedOutput
    }));

    try {
      // Initialize Gemini service
      const geminiService = new GeminiService();
      
      // Submit function-based solution using Gemini API
      const result = await geminiService.submitSolution(code, language, problemId, testCases, problem.functionSignature);

      // Determine final status
      let finalStatus = 'wrong_answer';
      if (result.status === 'accepted') {
        finalStatus = 'accepted';
      } else if (result.status === 'runtime_error') {
        finalStatus = 'runtime_error';
      } else if (result.status === 'compilation_error') {
        finalStatus = 'compilation_error';
      }

      // Save submission to database
      const submission = new Submission({
        user: userId,
        problem: problemId,
        code,
        language,
        status: finalStatus,
        executionTime: result.executionTime,
        memoryUsed: result.memoryUsed,
        passedTestCases: result.passedTestCases,
        totalTestCases: result.totalTestCases,
        testCaseResults: result.testCaseResults.map(tc => ({
          testCaseId: tc.testCaseNumber,
          status: tc.status === 'passed' ? 'Passed' : 'Failed',
          executionTime: tc.executionTime,
          memoryUsed: tc.memoryUsed,
          input: tc.input,
          expectedOutput: tc.expectedOutput,
          actualOutput: tc.actualOutput,
          errorMessage: tc.error
        })),
        compilationError: finalStatus === 'compilation_error' ? 'Function signature mismatch or compilation error' : undefined,
        runtimeError: finalStatus === 'runtime_error' ? 'Runtime error during execution' : undefined
      });

      await submission.save();

      // Update problem statistics
      await Problem.findByIdAndUpdate(problemId, {
        $inc: {
          totalSubmissions: 1,
          ...(finalStatus === 'accepted' && { acceptedSubmissions: 1 })
        }
      });

      res.json({
        success: true,
        data: {
          submissionId: submission._id,
          status: finalStatus,
          executionTime: result.executionTime,
          memoryUsed: result.memoryUsed,
          passedTestCases: result.passedTestCases,
          totalTestCases: result.totalTestCases,
          testCaseResults: result.testCaseResults
        }
      });

    } catch (geminiError) {
      console.error('Gemini API function submission error:', geminiError);
      res.status(500).json({
        success: false,
        message: 'Function-based solution submission failed via Gemini API',
        error: geminiError.message
      });
    }

  } catch (error) {
    console.error('Function-based solution submission error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Function-based solution submission failed',
      error: error.message
    });
  }
});

// Get user submissions for a problem
router.get('/submissions/:problemId', authenticateToken, async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { page = 1, limit = 10 } = req.query;

    const submissions = await Submission.find({
      userId,
      problemId
    })
    .sort({ createdAt: -1 })
    .limit(parseInt(limit))
    .skip((parseInt(page) - 1) * parseInt(limit))
    .select('-code -compilerOutput.testCaseResults');

    const totalSubmissions = await Submission.countDocuments({
      userId,
      problemId
    });

    res.json({
      success: true,
      data: {
        submissions,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalSubmissions / parseInt(limit)),
          totalItems: totalSubmissions,
          itemsPerPage: parseInt(limit)
        }
      }
    });

  } catch (error) {
    console.error('Error fetching submissions:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch submissions',
      error: error.message
    });
  }
});

// Get submission details
router.get('/submission/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const submission = await Submission.findOne({
      _id: id,
      userId
    }).populate('problemId', 'title');

    if (!submission) {
      return res.status(404).json({
        success: false,
        message: 'Submission not found'
      });
    }

    res.json({
      success: true,
      data: submission
    });

  } catch (error) {
    console.error('Error fetching submission:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch submission',
      error: error.message
    });
  }
});

// Get supported languages
router.get('/languages', async (req, res) => {
  try {
    // Return supported languages directly since we're using Gemini API
    const supportedLanguages = [
      {
        name: 'JavaScript',
        value: 'javascript',
        extension: '.js',
        description: 'JavaScript (Node.js)'
      },
      {
        name: 'Python',
        value: 'python',
        extension: '.py',
        description: 'Python 3'
      },
      {
        name: 'Java',
        value: 'java',
        extension: '.java',
        description: 'Java 11'
      },
      {
        name: 'C++',
        value: 'cpp',
        extension: '.cpp',
        description: 'C++17'
      },
      {
        name: 'C',
        value: 'c',
        extension: '.c',
        description: 'C99'
      }
    ];

    res.json({
      success: true,
      data: supportedLanguages
    });

  } catch (error) {
    console.error('Error fetching languages:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch supported languages',
      error: error.message
    });
  }
});

module.exports = router;
